{-# LANGUAGE DataKinds #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ViewPatterns #-}

module Development.NvFetcher
  ( module Development.NvFetcher.NixFetcher,
    module Development.NvFetcher.Nvchecker,
    module Development.NvFetcher.PackageSet,
    module Development.NvFetcher.Types,
    Args (..),
    defaultArgs,
    defaultMain,
    defaultMainWith,
  )
where

import Control.Concurrent.MVar (MVar, modifyMVar_, newMVar, readMVar)
import Data.Coerce (coerce)
import Data.Maybe (fromJust)
import qualified Data.Set as Set
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Development.NvFetcher.NixFetcher
import Development.NvFetcher.Nvchecker
import Development.NvFetcher.PackageSet
import Development.NvFetcher.Types
import Development.Shake
import NeatInterpolation (trimming)
import System.Console.GetOpt (OptDescr)

data Args = Args
  { argShakeOptions :: ShakeOptions,
    argOutputFilePath :: FilePath,
    argRules :: Rules ()
  }

defaultArgs :: Args
defaultArgs = Args shakeOptions "sources.nix" $ pure ()

defaultMain :: Args -> PackageSet () -> IO ()
defaultMain args packageSet = defaultMainWith args [] $ const $ pure packageSet

defaultMainWith :: Args -> [OptDescr (Either String a)] -> ([a] -> IO (PackageSet ())) -> IO ()
defaultMainWith args@Args {..} flags f = do
  var <- newMVar mempty
  shakeArgsWith
    argShakeOptions
      { shakeProgress = progressSimple,
        shakeExtra = addShakeExtra (GitCommitMessage var) mempty
      }
    flags
    $ \flagValues argValues -> case argValues of
      [] -> pure Nothing
      files -> do
        packageSet <- f flagValues
        pure $ Just $ want files >> mainRules args packageSet

mainRules :: Args -> PackageSet () -> Rules ()
mainRules Args {..} packageSet = do
  "clean" ~> do
    removeFilesAfter ".shake" ["//*"]
    removeFilesAfter "." [argOutputFilePath]

  "build" ~> do
    pkgs <- runPackageSet packageSet
    generateNixSources argOutputFilePath $ Set.toList pkgs
    setCommitMessageWhenInGitHubEnv

  argRules
  nvfetcherRules

--------------------------------------------------------------------------------
newtype GitCommitMessage = GitCommitMessage (MVar [Text])

appendGitCommitMessageLine :: Text -> Action ()
appendGitCommitMessageLine x = do
  GitCommitMessage var <- fromJust <$> getShakeExtra @GitCommitMessage
  liftIO $ modifyMVar_ var (pure . (++ [x]))

getGitCommitMessage :: Action Text
getGitCommitMessage = do
  GitCommitMessage var <- fromJust <$> getShakeExtra @GitCommitMessage
  liftIO $ T.unlines <$> readMVar var

-- | If we are in github actions, write the commit message into $COMMIT_MSG
setCommitMessageWhenInGitHubEnv :: Action ()
setCommitMessageWhenInGitHubEnv = do
  msg <- getGitCommitMessage
  getEnv "GITHUB_ENV" >>= \case
    Just env ->
      liftIO $ do
        appendFile env "COMMIT_MSG<<EOF\n"
        T.appendFile env msg
        appendFile env "\nEOF\n"
    _ -> pure ()

--------------------------------------------------------------------------------

nvfetcherRules :: Rules ()
nvfetcherRules = do
  nvcheckerRule
  prefetchRule

generateNixSources :: FilePath -> [Package] -> Action ()
generateNixSources fp pkgs = do
  body <- genBody
  getGitCommitMessage >>= \msg ->
    if T.null msg
      then putInfo "Up to date"
      else do
        putInfo "Changes:"
        putInfo $ T.unpack msg
  writeFileChanged fp $ T.unpack $ srouces $ T.unlines body
  putInfo $ "Generate " <> fp
  where
    single Package {..} = do
      (NvcheckerResult version mOld) <- askNvchecker pversion
      prefetched <- prefetch $ pfetcher version
      case mOld of
        Nothing ->
          appendGitCommitMessageLine (pname <> ": ∅ → " <> coerce version)
        Just old
          | old /= version ->
            appendGitCommitMessageLine (pname <> ": " <> coerce old <> " → " <> coerce version)
        _ -> pure ()
      pure (pname, version, prefetched)
    genOne (name, coerce @Version -> ver, toNixExpr -> srcP) =
      [trimming|
        $name = {
          pname = "$name";
          version = "$ver";
          src = $srcP;
        };
      |]
    genBody = parallel $ map (fmap genOne . single) pkgs
    srouces body =
      [trimming|
        # This file was generated by nvfetcher, please do not modify it manually.
        { fetchFromGitHub, fetchurl }:
        {
          $body
        }
      |]
